(function() {
  var ChartBase, GaugeChart,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (window.$ == null) {
    window.$ = require('jquery-commonjs');
  }

  ChartBase = require('./chart_base');

  GaugeChart = (function(_super) {
    __extends(GaugeChart, _super);

    GaugeChart.prototype.loadDefaults = function() {
      return this.defaults = {
        animationDuration: 1500,
        autoAnimate: true,
        unit: '%',
        formatFn: null,
        label: '',
        max: 100,
        maxLabel: null,
        avg: null,
        avgType: 'notch',
        value: null
      };
    };

    GaugeChart.prototype.loadMeta = function() {
      return this.meta = {
        gaugeStartAngle: -270,
        shadowStartAngle: -270,
        railOffsetAngle: 90,
        notchStartAngle: -135,
        zeroAngle: 0,
        maxAngle: 270,
        valueAngle: 0,
        avgAngle: 0
      };
    };

    function GaugeChart(options) {
      this.options = options;
      this.loadDefaults();
      this.loadMeta();
      this.options = $.extend({}, this.defaults, this.options);
      if (this.options.formatFn) {
        this.formatValue = this.options.formatFn;
      }
      this.normalizeParameters();
      this.$el = options.el;
      this.$el.addClass(this.$el.attr('class'));
      this.rail = this.createElement('pillow-gauge-rail');
      this.gauge = this.createElement('pillow-gauge-gauge');
      this.caption = this.createCaption();
      this.$el.append(this.rail, this.gauge, this.caption);
      if (this.options.maxLabel != null) {
        this.$el.append(this.createMaxLabelElement());
      }
      this.setGaugeRotation(this.meta.zeroAngle);
      this.setCaption(0);
      this.meta.valueAngle = this.convertToAngle(this.options.value);
      this.createAvgIndicator();
    }

    GaugeChart.prototype.createAvgIndicator = function() {
      if (this.isAvgTypeNotch()) {
        this.notch = this.createElement('pillow-gauge-notch').appendTo(this.$el);
        this.setNotchRotation(this.meta.zeroAngle);
        this.meta.avgAngle = this.convertToAngle(this.options.avg);
      }
      if (this.isAvgTypeShadow()) {
        this.shadow = this.createElement('pillow-gauge-shadow').appendTo(this.$el);
        this.setShadowRotation(this.meta.zeroAngle);
        return this.meta.avgAngle = this.convertToAngle(this.options.avg);
      }
    };

    GaugeChart.prototype.isAvgTypeNotch = function() {
      return this.options.avg && this.options.avgType === 'notch';
    };

    GaugeChart.prototype.isAvgTypeShadow = function() {
      return this.options.avg && this.options.avgType === 'shadow';
    };

    GaugeChart.prototype.createElement = function(className) {
      return $('<div></div>').addClass(className);
    };

    GaugeChart.prototype.createCaption = function() {
      var $caption;
      $caption = this.createElement('pillow-gauge-caption');
      $caption.append(this.createElement('value'), this.createElement('unit').html(this.options.unit), this.createElement('label').html(this.options.label));
      return $caption;
    };

    GaugeChart.prototype.createMaxLabelElement = function() {
      var $maxLabel;
      $maxLabel = this.createElement('pillow-gauge-max-label');
      $maxLabel.text(this.options.maxLabel);
      return $maxLabel;
    };

    GaugeChart.prototype.normalizeParameters = function() {
      if (this.options.value < 0) {
        this.options.value = 0;
      }
      if (this.options.value > this.options.max) {
        this.options.value = this.options.max;
      }
      if (this.options.avg) {
        if (this.options.avg < 0) {
          this.options.avg = 0;
        }
        if (this.options.avg > this.options.max) {
          return this.options.avg = this.options.max;
        }
      }
    };

    GaugeChart.prototype.convertToAngle = function(value) {
      value = value / this.options.max;
      if (value > 0 && value < 0.01) {
        value = 0.01;
      }
      return Math.round(this.meta.maxAngle * value);
    };

    GaugeChart.prototype.render = function() {
      if (this.options.autoAnimate) {
        return this.animate();
      }
    };

    GaugeChart.prototype.animate = function() {
      var endTime, requestAnimFrameListener, startTime;
      this.$el.trigger('animationstart');
      startTime = new Date().getTime();
      endTime = startTime + this.options.animationDuration;
      requestAnimFrameListener = (function(_this) {
        return function() {
          var gaugeAngle, progress, progressAngle;
          progress = _this.getAnimationProgress(new Date().getTime(), startTime, endTime);
          progressAngle = _this.getProgressAngle(progress);
          if (progressAngle > _this.meta.maxAngle) {
            gaugeAngle = _this.meta.maxAngle;
          } else {
            gaugeAngle = progressAngle;
          }
          _this.setGaugeRotation(gaugeAngle);
          _this.setCaption(_this.getProgressValue(progress));
          _this.setAvgIndicatorRotation(progress);
          if (progress === 1) {
            return _this.$el.trigger('animationend');
          } else {
            return requestAnimationFrame(function() {
              return requestAnimFrameListener();
            });
          }
        };
      })(this);
      return requestAnimFrameListener();
    };

    GaugeChart.prototype.setGaugeRotation = function(angle) {
      var gaugeAngle, railAngle;
      if (angle > this.meta.maxAngle) {
        angle = this.meta.maxAngle;
      }
      if (angle < this.meta.zeroAngle) {
        angle = this.meta.zeroAngle;
      }
      this.setGaugeProportions(angle);
      gaugeAngle = this.meta.gaugeStartAngle + angle;
      railAngle = gaugeAngle + this.meta.railOffsetAngle;
      this.rotate(this.gauge, gaugeAngle);
      return this.rotate(this.rail, railAngle);
    };

    GaugeChart.prototype.setGaugeProportions = function(angle) {
      var $gauge, $rail;
      $rail = this.rail[0];
      $gauge = this.gauge[0];
      $rail.classList.remove('third', 'half', 'full');
      $gauge.classList.remove('third', 'half', 'full');
      switch (false) {
        case !(angle < 90):
          $rail.classList.add('full');
          return $gauge.classList.add('third');
        case !(angle < 180):
          $rail.classList.add('half');
          return $gauge.classList.add('half');
        default:
          $rail.classList.add('third');
          return $gauge.classList.add('full');
      }
    };

    GaugeChart.prototype.setAvgIndicatorRotation = function(progress) {
      if (this.isAvgTypeNotch()) {
        this.setNotchRotation(this.getProgressAvgAngle(progress));
      }
      if (this.isAvgTypeShadow()) {
        return this.setShadowRotation(this.getProgressAvgAngle(progress));
      }
    };

    GaugeChart.prototype.setShadowRotation = function(angle) {
      this.setShadowProportions(angle);
      return this.rotate(this.shadow, this.meta.shadowStartAngle + angle);
    };

    GaugeChart.prototype.setShadowProportions = function(angle) {
      this.shadow.removeClass('third half full');
      switch (false) {
        case !(angle < 90):
          return this.shadow.addClass('third');
        case !(angle < 180):
          return this.shadow.addClass('half');
        default:
          return this.shadow.addClass('full');
      }
    };

    GaugeChart.prototype.setNotchRotation = function(angle) {
      var notchAngle;
      if (angle > this.meta.maxAngle) {
        angle = this.meta.maxAngle;
      }
      if (angle < this.meta.zeroAngle) {
        angle = this.meta.zeroAngle;
      }
      notchAngle = this.meta.notchStartAngle + angle;
      return this.rotate(this.notch, notchAngle);
    };

    GaugeChart.prototype.setCaption = function(value) {
      return this.caption.find('.value').text(this.formatValue(value));
    };

    GaugeChart.prototype.getAnimationProgress = function(currentTime, startTime, endTime) {
      var delta, progress;
      progress = (currentTime - startTime) / (endTime - startTime);
      if (progress > 1) {
        progress = 1;
      }
      delta = this.makeEaseOut(progress);
      return delta;
    };

    GaugeChart.prototype.makeEaseOut = function(progress) {
      return 1 - Math.pow(1 - progress, 5);
    };

    GaugeChart.prototype.getProgressAngle = function(percentage) {
      return Math.round(this.meta.valueAngle * percentage);
    };

    GaugeChart.prototype.getProgressAvgAngle = function(percentage) {
      return Math.round(this.meta.avgAngle * percentage);
    };

    GaugeChart.prototype.getProgressValue = function(percentage) {
      return Math.round(this.options.value * percentage * 100) / 100;
    };

    GaugeChart.prototype.formatValue = function(value) {
      var d;
      d = this.options.value < 100 ? 2 : 0;
      return parseFloat(value).toFixed(d);
    };

    GaugeChart.prototype.rotate = function($el, angle) {
      var value;
      value = "rotate(" + angle + "deg)";
      $el.css('-webkit-transform', value);
      return $el.css('transform', value);
    };

    return GaugeChart;

  })(ChartBase);

  module.exports = GaugeChart;

}).call(this);
